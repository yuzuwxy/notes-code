输入运算符cin>>的构成：   cin和>>
    cin是输入流istream的一个对象，隶属于iostream函数库
    >>是运算符，其作用是从左侧的cin对象中读取数据，并将它赋给右侧的运算对象
cin仅仅是一个istream对象，它的值反映的是当前输入流的状态：即cin对象接下来能否进行输入操作（能否从cin对象中读取数据)

cin对象实际上面向两方面的功能：
    1.外部设备与cin之间：这部分对于程序员来说是透明的
     设备（键盘）对它的修改，即通过设备直接修改cin对象，通过这个可以直接修改cin对象的状态（能否从cin对象中读取数据）
    2.cin和内存（各种对象，变量）之间：
    将cin中的数据读取出来，并赋予各种对象，变量

而这两方面的功能都不由cin对象完成，cin对象实际上只是一个状态数据量，1功能有外设（键盘）完成，2功能由<<和getline等等运算符完成

>>运算符的作用实际上就是从cin对象中读取数据，并将数据赋予给右侧的各种对象或者变量
    1.>>运算符是由右侧的数据类型定义的，右侧的数据类型不同，重载的>>也不同
    2.>>运算符是向左结合的
    3.>>运算符从cin对象中读取数据时：如果遇到空格或者换行符号，那么这次读取数据结束，将空格之前的数据赋给右侧的运算对象,相应的，读取的第一个符号，也是空格或者换行符之后的第一个有效数据
    4.一个>>运算符一次只能读取一次（一个）数据，要想读取多个数据，只能再加>>运算符
    
getline是一种特殊的cin，特殊性体现在：
    由string对象定义，只用于string对象；
    getline遇到空格不结束，也就是说它可以从cin对象中读取空格。遇到换行符仍然结束，但是也会读取换行符，在读取换行符之后停止读取。然后将读的数据（包括换行符）赋值给右侧的运算对象x ，赋值的时候
  会丢弃换行符。
    getline调用是函数的形式：
        string x;
        getline(cin ,x);
        
        
        
//好厉害


使用cin对输入的参数进行数据类型的判断：           （代码及输出结果见try——>3)
    首先写出正确的应用方式：
        int main() {
            int temp;
            while(1) {
                cout<<"Enter it:"<<endl;;
                cin>>temp;                               //输入值为12时，为理想输入，打印"GOOD"
                if(!cin){                                //输入值为1.5时，会首先打印出"GOOD",这是因为操作符"<<"逐个抽取流中的数据，不断与int类型匹配，哪怕只是部分匹配，cin对
                    cout<<"BAD"<<endl;                   //象的标记位都不会改变，可以正常输入。也就是"1.5"中的"1"可以先被抽出进入循环打印出"GOOD".
                    cin.clear();
                    while(cin.get()!='\n')  continue;           输出：
                }                                                   Enter it:                   Enter it:                       Enter it:
                else cout<<"GOOD"<<endl;                            12                          1.5                             qwe
                return 0;                                           GOOD                        GOOD                            BAD
            }                                                                                   Enter it:
        }                                                                                       BAD
    输入值为12时，为理想输入，打印"GOOD"     
    输入值为1.5时，会首先打印出"GOOD",这是因为操作符"<<"逐个抽取流中的数据，不断与int类型匹配，哪怕只是部分匹配，cin对象的标记位都不会改变，可以正常输入。也就是"1.5"中的"1"可以先被抽出进
入循环打印出"GOOD"。一旦输入完全不匹配，操作符">>"无法进行任何抽取，返回的cin对象fail标记位置1，good标记位置0。这种状态在cin.clear()生效之前（标记位重置），（这几句话啥意思没懂啊），会使
输入流不能再进行继续的输入。而这种性质也就导致了本例中对于"1.5"的输入，在打印完"GOOD"后没有经历任何的输入就马上打印"BAD".触发这种状况的是字符'.'进入判断条件，而无论后面接'5'还是接'a'都对
结果没有影响。因为他们已经被接下来的代码段清空了：
        cin>>clear();
        while(cin.get()!='\n') continue;
 
   如果注释掉这两句代码，输出结果为：
        //无限输出BAD
        
  一旦输入不符合要求的值，将无限打印"BAD".
  以输入"1.5"为例，如果没有上述代码清除缓存中的“坏数据”，那么对于字符'.'就处在了一个尴尬的位置。虽然在它引发了第一次错误后重置了标记位，但这并不会使它具有通过语句"cin>>temp"而进入一个int
  类型的变量的特权。这也是cin必须具备的特质，否则便无法称职的保护输入流。所以此时的局面就被描述为为：
        '.'永远在输入缓存区的最前端被拿来不断调用，使程序不断地打印"BAD",但其本身永远无法跨过cin这道关卡。
        
        
  //没懂标记位是个啥玩意，也没搞懂cin.get() 那两句话是干嘛的，但是我get到了核心思想√




//cin的详细用法

cin简介

在理解 cin 功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键（\r）会被转换为一个换行符（\n）。
这个换行符也会被存储在 cin 的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了 123456 这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，
那么此时缓冲区中的字节个数是 7 ，而不是 6。

cin 读取数据也是从缓冲区中获取数据，缓冲区为空时，cin 的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发 cin 的成员函数去读取数据。

cin的读取方法有
cin>>       cin.get()       cin.getline()

cin的具体用法

cin可以连续从键盘获取想要的数据，以空格，换行符或回车作为分隔符。也就是说只读到空格，换行，或者回车

（1）cin>>相当于cin.operator()>>，即调用成员函数operator>>()进行调用
（2）当 cin>> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。
    但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>> 不做处理。
（3）不想略过空白字符，就使用noskinpws>>流控制，比如cin>>noskinpws>>input

#include <string> 
#include <iostream>
using namespace std;

int main()
{
	char a;
	int b;                                                      //从键盘输入:[回车][回车][回车]a[回车]5[回车]2.33[回车]hello[回车]，输出结果是：
	float c;                                                            //a 5 2.33 hello
	string str;                                                         //test:
	cin>>a>>b>>c>>str;                                          //从结果可以看出，cin>> 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来. 
    cout<<a<<" "<<b<<" "<<c<<" "<<str<<endl;                        //但是，getline() 读取数据时，并非像 cin>> 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符.
                                                                   //不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。
	string test;
	getline(cin,test);//不阻塞
	cout<<"test:"<<test<<endl;
	return 0;
}


