输入运算符cin>>的构成：   cin和>>
    cin是输入流istream的一个对象，隶属于iostream函数库
    >>是运算符，其作用是从左侧的cin对象中读取数据，并将它赋给右侧的运算对象
cin仅仅是一个istream对象，它的值反映的是当前输入流的状态：即cin对象接下来能否进行输入操作（能否从cin对象中读取数据)

cin对象实际上面向两方面的功能：
    1.外部设备与cin之间：这部分对于程序员来说是透明的
     设备（键盘）对它的修改，即通过设备直接修改cin对象，通过这个可以直接修改cin对象的状态（能否从cin对象中读取数据）
    2.cin和内存（各种对象，变量）之间：
    将cin中的数据读取出来，并赋予各种对象，变量

而这两方面的功能都不由cin对象完成，cin对象实际上只是一个状态数据量，1功能有外设（键盘）完成，2功能由<<和getline等等运算符完成

>>运算符的作用实际上就是从cin对象中读取数据，并将数据赋予给右侧的各种对象或者变量
    1.>>运算符是由右侧的数据类型定义的，右侧的数据类型不同，重载的>>也不同
    2.>>运算符是向左结合的
    3.>>运算符从cin对象中读取数据时：如果遇到空格或者换行符号，那么这次读取数据结束，将空格之前的数据赋给右侧的运算对象,相应的，读取的第一个符号，也是空格或者换行符之后的第一个有效数据
    4.一个>>运算符一次只能读取一次（一个）数据，要想读取多个数据，只能再加>>运算符
    
getline是一种特殊的cin，特殊性体现在：
    由string对象定义，只用于string对象；
    getline遇到空格不结束，也就是说它可以从cin对象中读取空格。遇到换行符仍然结束，但是也会读取换行符，在读取换行符之后停止读取。然后将读的数据（包括换行符）赋值给右侧的运算对象x ，赋值的时候
  会丢弃换行符。
    getline调用是函数的形式：
        string x;
        getline(cin ,x);
        
        
        
//好厉害


使用cin对输入的参数进行数据类型的判断：           （代码及输出结果见try——>3)
    首先写出正确的应用方式：
        int main() {
            int temp;
            while(1) {
                cout<<"Enter it:"<<endl;;
                cin>>temp;                               //输入值为12时，为理想输入，打印"GOOD"
                if(!cin){                                //输入值为1.5时，会首先打印出"GOOD",这是因为操作符"<<"逐个抽取流中的数据，不断与int类型匹配，哪怕只是部分匹配，cin对
                    cout<<"BAD"<<endl;                   //象的标记位都不会改变，可以正常输入。也就是"1.5"中的"1"可以先被抽出进入循环打印出"GOOD".
                    cin.clear();
                    while(cin.get()!='\n')  continue;           输出：
                }                                                   Enter it:                   Enter it:                       Enter it:
                else cout<<"GOOD"<<endl;                            12                          1.5                             qwe
                return 0;                                           GOOD                        GOOD                            BAD
            }                                                                                   Enter it:
        }                                                                                       BAD
    输入值为12时，为理想输入，打印"GOOD"     
    输入值为1.5时，会首先打印出"GOOD",这是因为操作符"<<"逐个抽取流中的数据，不断与int类型匹配，哪怕只是部分匹配，cin对象的标记位都不会改变，可以正常输入。也就是"1.5"中的"1"可以先被抽出进
入循环打印出"GOOD"。一旦输入完全不匹配，操作符">>"无法进行任何抽取，返回的cin对象fail标记位置1，good标记位置0。这种状态在cin.clear()生效之前（标记位重置），（这几句话啥意思没懂啊），会使
输入流不能再进行继续的输入。而这种性质也就导致了本例中对于"1.5"的输入，在打印完"GOOD"后没有经历任何的输入就马上打印"BAD".触发这种状况的是字符'.'进入判断条件，而无论后面接'5'还是接'a'都对
结果没有影响。因为他们已经被接下来的代码段清空了：
        cin>>clear();
        while(cin.get()!='\n') continue;
 
   如果注释掉这两句代码，输出结果为：
        //无限输出BAD
        
  一旦输入不符合要求的值，将无限打印"BAD".
  以输入"1.5"为例，如果没有上述代码清除缓存中的“坏数据”，那么对于字符'.'就处在了一个尴尬的位置。虽然在它引发了第一次错误后重置了标记位，但这并不会使它具有通过语句"cin>>temp"而进入一个int
  类型的变量的特权。这也是cin必须具备的特质，否则便无法称职的保护输入流。所以此时的局面就被描述为为：
        '.'永远在输入缓存区的最前端被拿来不断调用，使程序不断地打印"BAD",但其本身永远无法跨过cin这道关卡。
        
        
  //没懂标记位是个啥玩意，也没搞懂cin.get() 那两句话是干嘛的，但是我get到了核心思想√
