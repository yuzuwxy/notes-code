stringstream是C++提供的字符串流，要使用stringstream必须包含其头文件：
        #include<sstream>
        using namespace std;
        stringstream ss
<sstream > 库定义了三种类：istringstream、ostringstream和stringstream，分别用来进行流的输入、输出和输入输出操作。一般情况下使用stringstream就足够，因为字符串要频繁的涉及到输入输出。
通过插入器(<<)和析取器(>>)这两个运算符可以直接对stringstream上的数据输入输出，而将stringstream中的全部数据输出则是使用成员函数str()，其有两种形式：
        void str();     //无参形式，用于将stringstream流中的数据以string字符串的形式输出
        void str(const string& s);     //(不咋懂）以字符串为参数，用以覆盖stringstream流中的数据
        
        需要注意的是：
                ss.str("");        //字符串流清零， 将流中的数据全部清除
        示例代码： 
            #include<iostream>
            #include<string>
            #include<sstream>
            using namespace std;
            int main(){
	            stringstream ss;
	            ss<<"hello ";                // 在流中插入"hello "
	            ss<<"world!";                //在流中插入"world!"
	            cout<<ss.str()<<endl;       //将流中的数据以字符串的形式输出"hello world!"
                return 0;
            }
            //对于stringstream而言，操作<<是一直往字符串流中写字符，而不是覆盖之前输入的字符
            //这一点不同于str()成员函数方法，str()函数创建的是一个临时的string对象，这个string对象在函数str()语句结束就会被销毁
            //因而一般使用时先声明一个string对象s，将str()赋值给s
            //const string s=ss.str(), 这样会有一个string拷贝的过程
            //又或者是const string& s=ss.str(), 这样就是s直接引用了ss.str()这个临时变量，这样就延长了临时变量ss.str()的生命周期，使得ss.str()的生命结束时刻与s一样
ss.clear()成员函数：
    通过clear()成员函数可以清除流的错误状态，主要用在stringstream重复使用时或者多个stringstream对象构造时清空，不然之前的缓冲就停留在输入输出流中
    对于同一个stringstream对象重复赋值，就需要先对流使用clear()函数清空流的状态，此时流占用的内存没有改变，会一直增加（stringstream不主动释放内存），若想改变内存（一般是清除内存，减少
   内存消耗），需要再配合使用str("")清空stringstream的缓存。
   	
   	stringstream ss;
	int a,b;
	ss<<"80";
	ss>>a;
	cout<<ss.str()<<' '<<ss.str().length()<<endl;
	ss.clear();
	ss.str("");							
	cout<<ss.str()<<' '<<ss.str().length()<<endl;
	ss<<"90";
	ss>>b;
	cout<<ss.str()<<' '<<ss.str().length()<<endl;
        return 0;
