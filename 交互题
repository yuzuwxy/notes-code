//比较神奇以前从来没看过（为啥我突然觉得字体变大了）
简介：
    可以理解为有个问题需要你解决，你通过输入某些东西表示你要问系统的问题，这时系统会回答你的问题。
    在代码中的回答方式就是会输入某个东西就是系统给你的答案，通过这些信息你可以得到问题的解。
    你是不可以自己测试的，只能提交给系统测试。
    //不太懂，看例题叭

第一道例题：
https://codeforces.com/contest/1167/problem/B
题意：一个包含6个元素的数字序列，进行不超过四次询问，询问内容为下标为i和j的两个数的乘积。输入的是答案，输出的是询问内容和可能的一个数字序列。
     噢英语也不太好，数字序列里的数字是定的，就是排列顺序不一样。
思路：好暴力啊这个题。
//还是有点东西
#include<bits/stdc++.h>

using namespace std;

#define ll long long
//交互，就是人机交互的交互
int a[6]={4,8,15,16,23,42};
int db[6];

int main() {
    for(int i=1;i<=4;i++) {
        printf("? %d %d\n",i,i+1);        //系统测试的时候，这里输出的数其实是向系统输入的数
        fflush(stdout);
        scanf("%d",&db[i]);               //这里输入的数实际是系统输出的数
    }

    do{
        if(a[0]*a[1]==db[1]&&a[1]*a[2]==db[2]&&a[2]*a[3]==db[3]&&
            a[3]*a[4]==db[4])
        break;
    }while(next_permutation(a,a+6));         //这个函数是库里的STL函数，全排列函数（根据字典序）。do{}while()相当于是固定格式
    printf("!");
    for(int i=0;i<6;i++) {
        printf(" %d",a[i]);
    }
    cout<<endl;
    return 0;
}
//啊我也不知道怎么说自己悟吧

第二道例题：
https://codeforces.com/problemset/problem/679/A
题意：在[2,100]之间有一个隐藏的数字想要知道是素数还是合数，可以进行最多20次询问。询问的方式是输入一个数然后回答输入的数是否是隐藏的数字的因子。所有询问完成之后回答这个数是素数还是合数。
思路：最多能问20次，那我就问20次肯定问的出来。判断是否是素数的方法一般是循环[2,sqrt(x)],如果有一个数可以整除就说明不是素数。然后仔细想想100开根号也不过是10，也许可以直接循环？
//试试
//试试就逝世。有问题。如果这个数是22以内的素数，那就是只有一个数可以被整除；如果是22以外的素数，那就没有数字可以被整除；如果在22以内只有一个因数的合数，也只有一个数被整除。所以遍历所有数计数不可行。
//没法用判断素数的方法跑那就用判断合数的方法跑。合数的性质就是可以写成若干个素数的乘积，也就是说如果是合数必然有一个素数是因子。那就问素数，如果有一个素数是因子，就说明不是。最多询问20次，找到20个素数：
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47，如果47是因数，那另一个最多是2到了96，97是质数，98有2,99有3，那就完了，问这么多应该就够了，试试。
如果是这部分的素数，会有一个因数；如果不是这部分的素数就没有因数；如果是合数，也有可能只有一个因子，如果是某个数的平方的话，如果是立方平方数会再加一个因子。平方数是100以内的也只有2，3，5。
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    int prime[20]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49};    //打表
    int ans=0;
    for(int i=0;i<=18;i++) {    
        printf("%d\n",prime[i]);
        fflush(stdout);
        char ch[10];
        scanf("%s",ch);
        if(strcmp(ch,"yes")==0) ans++;
    }
    if(ans<=1) printf("prime\n");
    else printf("composite\n");        //英语单词还是复制粘贴吧自己打要错的
    return 0;
}

//自己做咯
https://vjudge.net/problem/CodeForces-1451E1/origin
遭遇滑铁卢
题目的意思大概是一个数字序列长度为n(保证是2的幂次),可以根据数组索引对任意两个数的AND，OR，XOR进行询问，询问次数不超过n+2,求的是这个数字序列。
//英语不好交互题的题目死难看
沙雕思路：一个数跟0按位或得到的还是这个数，所以让第一个数是0，然后依次问每个数跟这个数的或，只需要问n-1次。好憨啊主要是没啥思路。
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    ll n;
    scanf("%lld",&n);
    vector<ll> arr(n+1);
    arr[0]=0;
    for(ll i=1;i<n;i++) {
        printf("OR %lld 0\n",i);
        fflush(stdout);
        ll ans;
        scanf("%lld",&ans);
        arr[i]=ans;
    }
    printf("!");
    for(ll i=0;i<n;i++) {
        printf(" %lld",arr[i]);
    }
    printf("\n");
    return 0;
}
大概就是不能自己定数组里的数吧，人家可能有唯一答案┭┮﹏┭┮
翻了题解：
设 x = a + b , y = a + c , z = b + c
因为 a + b = ( a ⊕ b ) + 2 ∗ ( a & b )     //咱也不知道为啥先记着吧
而 ( a ⊕ b ) ⊕ ( a ⊕ c ) = b ⊕ c，所以只需要知道 a & b , a & c , b & c , a ⊕ b , a ⊕ c 这五项就能算出x , y , z 三个数，进而推出 a , b , c  三个数，最后剩下的 n − 3个数，只要一次 ⊕ 就可以解决，因此总共查询的次数为 5 + n − 3 = n + 2次
位运算真的是太优美了（划掉）
淦啊好强，这谁能想到啊
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    int n;
    scanf("%d",&n);
    vector<int> res(n+1,0);
    int ab1,ab2,ac1,ac2,bc1,bc2;
    int x,y,z;
    printf("XOR 1 2\n");
    fflush(stdout);
    scanf("%d",&ab1);

    printf("AND 1 2\n");    
    fflush(stdout);
    scanf("%d",&ab2);

    printf("XOR 1 3\n");
    fflush(stdout);
    scanf("%d",&ac1);

    printf("AND 1 3\n");
    fflush(stdout);
    scanf("%d",&ac2);

    bc1=ab1^ac1;

    printf("AND 2 3\n");
    fflush(stdout);
    scanf("%d",&bc2);

    x=ab1+2*ab2;
    y=ac1+2*ac2;
    z=bc1+2*bc2;

    res[1]=(x+y-z)/2;
    res[2]=(x+z-y)/2;
    res[3]=(y+z-x)/2;

    int p;
    for(int i=4;i<=n;i++) {
        printf("XOR 1 %d\n",i);
        fflush(stdout);
        scanf("%d",&p);
        res[i]=p^res[1];          //这里还有一个式子a^b^a=b
    }
    printf("!");
    for(int i=1;i<=n;i++) {
        printf(" %d",res[i]);
    }
    printf("\n");
    fflush(stdout);
    return 0;
}
